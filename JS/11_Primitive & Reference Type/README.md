# 원시 값과 객체의 비교

## Primitive Type

- Primitive Type 의 데이터는 변경 불가능한 값(`immutable value`) 이다.
    - Primitive Type 을 변수에 할당하면, 변수(즉, 식별자가 확보한 메모리 공간)에는 실제의 값이 저장된다.
    - Pirmitive Type 의 값을 가지는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다.
    이를 값에 의한 전달 `Pass By Value` 라고 한다.

### *왜 Primitive Type 은 불변할까?*

- 먼저 불변의 주체가 변수를 가리키는지 변수에 할당되는 값을 가리키는지 파악해야한다.
- 변수는 말그대로 값에 대한 **별칭**이므로 어떤 값이든 **재할당하여 변경** 가능하다.
- 하지만 변수에 할당되는 그 **“값(value)”** 은 오직 읽기 전용으로 메모리에 할당되며, 
변수에 새로운 값을 재할당 할 경우 새로운 값에 대한 메모리 공간을 확보하고, 확보한 메모리의 주소를 대상이 되는 변수가 값으로 가진다.
- 즉, 변수의 값이 변경되는 것은 기존의 값 자체가 변경되는 것이 아닌 메모리 주소에서 새로운 값의 메모리 주소를 기존 값으로 대체하여 변수의 값이 변경되는 것 처럼 보이는 것이다.
- 만약 Primitive Type 데이터가 가변성의 특징을 띈다면, 의도치 않게 값이 변경 될 수 있는 가능성이 존재하고, 이는 데이터 추적을 어렵게 만든다.

```jsx
// num 변수는 10 이라는 값이 저장된 메모리 공간의 주소를 값으로 가진다.
let num = 10;

// num 변수에 20 이라는 값으로 재할당하게 되면 20 이라는 값이 저장된 메모리 공간의 주소로 값이 대체된다.
// 만약 10 을 저장하고 있는 메모리를 참조하는 곳이 없다면 GC 에 의해 해당 메모리는 정리된다.
num = 20;
```

### 문자열과 불변성

- C 언어나 자바와는 다르게 자바스크립트에서는 문자열을 Primitive Type 으로도 제공한다.
(자바에서 문자열은 Reference Type 으로 Heap 메모리에 저장되며, 한 번 만들어진 문자열은 별도의 메모리 공간에 저장된다.)
- 자바스크립트에서는 값을 메모리에 저장 할 때, 메모리 공간의 크기를 미리 지정하는데 문자열의 경우 `2byte`, 숫자 타입의 경우 `8byte` 만큼의 메모리 공간을 확보한다. 
다만 다른 타입의 경우 브라우저의 엔진에 따라 확보하는 공간의 크기가 다르다는 것을 인지하고 있자.
- 자바스크립트의 문자열은 0개 이상의 문자(Character) 로 이루어져 있는 집합을 의미하는데, 이는 유사 배열이며, 이터러블이므로 배열과 유사하게 각 문자에 접근 할 수 있다.
- 즉, `“Hello”` 라는 문자열을 변수에 할당할 때, 각 문자들은 `2byte` 의 메모리 공간을 가지게 되고 각 메모리 공간을 배열처럼 이어서 변수에 할당한다.
- 또한, 문자열은 Primitive Type 으로 값 변경이 불가능한 `immutable` 한 데이터이다.
즉, 변수에 새로운 문자열로 재할당 할 경우 재할당 될 문자열이 새로운 메모리 공간을 확보하고 해당 메모리 주소가 변수의 값으로 새롭게 대체된다.

```jsx
let hello = "안녕하세요"; // 각 문자마다 2byte 의 메모리 공간을 가진다.

// 새로운 문자열로 재할당 할 경우 "안녕하세요" 문자열의 각 문자 값이 변경되는 것이 아니다.
// 새로운 문자열은 메모리 공간을 확보하고, 해당 주소는 대상이 되는 변수의 값에 대체된다.
// 즉, 메모리에는 "Hello" 와 "안녕하세요" 두 문자열이 존재하게 된다.
hello = "Hello";

/*
	유사 배열 객체?
	문자열의 각 문자는 개별적인 메모리 공간을 가지고 있으므로 배열과 비슷한 구조를 가지게 된다.
	즉, 배열처럼 인덱스를 사용해 문자열에 특정 인덱스에 위치한 문자에 직접 접근 할 수 있으며,
	문자열의 총 길이를 조회하거나 for 문을 통해 순회를 돌 수 있다.
*/

console.log(hello[0]); // "H" 출력

// Auto Casting 을 통해 String() 참조 객체로 자동으로 캐스팅되어 객체처럼 작동하여
// 객체에 존재하는 함수들을 사용 할 수 있다.
console.log(hello.length); // 5
console.log(hello.toLowerCase()); // hello
```

### 값에 의한 전달

- 자바스크립트에서는 Primitive  Type 의 값이 할당된 변수를 다른 변수에 할당하는 경우,
대상이 되는 변수 자체를 하나의 표현식으로 바라보기 때문에 
**대상 변수가 참조하고 있는 데이터의 메모리 주소에 존재하는 값을 새로운 메모리 공간에 할당하고 해당 메모리 주소를 복사본 변수의 값으로 할당한다.**
- 즉, 이러한 값의 전달이 대상 변수가 값으로 가지고 있는 메모리 주소 그대로 복사본 변수의 값으로 할당하는 것이 아니다.
- 그렇기 때문에 대상 변수와 복사본 변수의 실질적인 데이터는 같을지라도, **각 데이터가 저장된 메모리 주소는 다르다. 그러므로 대상 변수와 복사본 변수의 데이터는 다른 데이터이다.**
결국 대상 변수와 복사본 변수의 원시 값은 서로 다른 메모리 공간에 저장된 각기 다른 값이기 때문에 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭 할 수 없다.

```jsx
let age = 100;
let copy = age;

console.log(age, copy); // 100, 100
console.log(age === copy); // true > 데이터는 같지만 서로 저장된 메모리 주소는 다르다.

// 200 이라는 값을 새로운 메모리 공간을 확보하고 해당 메모리의 주소를 age 변수의 값에 재할당한다.
age = 200;

console.log(age, copy); // 200, 100
console.log(age === copy); // false
```

## Reference Type

- Reference Type 의 데이터는 변경 가능한 값(`mutable value`) 이다.
    - Reference Type 을 변수에 할당하면, 변수에는 값이 저장된 메모리 주소가 저장된다. 즉, 값이 실제로 존재하는 메모리 공간을 참조하게 된다는 의미이다.
    - Reference Type 의 값을 가지는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달된다. 즉, 복사되는 변수는 대상이 되는 객체의 메모리 주소를 기존 변수와 함께 참조하게 된다는 의미이다.
    이를 참조에 의한 전달 `Pass By Reference` 라고 한다.

## Object

- 객체는 프로퍼티의 개수가 정해져 있지 않으며(즉, 빈 객체가 존재 할 수 있다.), 프로퍼티의 추가와 삭제, 수정을 동적으로 수행 할 수 있다.
- 또한, 프로퍼티의 값은 어떤 데이터 타입이든(함수도 하나의 객체이기 때문에 가능하다.) 할당 할 수 있지만, 프로퍼티의 Key 값은 문자열 혹은 Symbol 타입만 설정 할 수 있다.
- 프로퍼티의 값에 어떤 데이터 타입이 할당될지 사전에 알 수 없기 때문에 프로퍼티를 설정 할 때 메모리 공간의 크기를 미리 정해둘 수 없다.

### ***자바스크립트의 객체 관리 방식***

- 자바스크립트의 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다. 하지만 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 더 높은 성능을 위해 나은 방법으로 객체를 구현한다.
- 자바나 C++ 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스 기반으로 객체를 생성하는 반면, 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 이는 프로토타입 기반의 언어이기 때문이다.
또한, 동적으로 프로퍼티를 제어할 수 있지만, 정적인 클래스 기반 객체지향 프로그래밍 언어에 비해 동적 제어를 위해 많은 비용이 드는 단점이 존재한다.

### 변경 가능한 값

- 자바스크립트의 객체는 변경 가능한 값이다.
    - 원시 타입의 값이 할당된 변수는 해당 변수가 기억하고 있는 메모리 주소에 접근 했을 때 값 가체를 가지게 된다. 이 때, 원시 타입이 할당된 메모리는 변경 불가능하기 때문에 다른 값으로 변경하기 위해서는 변수가 기억하고 있는 메모리 주소가 다른 값이 할당된 메모리 주소로 변경된다. (**재할당**)
    - 하지만 객체가 할당된 변수는 해당 변수가 기억하고 있는 메모리 주소에 접근 했을 때 객체가 할당된 메모리 주소를 가지고 있으며(**참조**), 객체의 프로퍼티를 변경한다고 하더라도 해당 변수에 재할당하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.
        - 이 때, 객체를 생성하는 것은 굉장히 큰 비용이 드는 작업이다. (원시 타입처럼 정해진 크기만큼 메모리 공간을 확보하지 않기 때문) 때문에 변수에 할당된 객체를 변경할 때 마다 원시 값을 복사해서 새롭게 생성한다면 데이터의 신뢰성이 확보되지만, 객체의 크기가 클 수도 있고, 프로퍼티에 객체가 할당 할 수 있기 때문에 객체를 복사한다는 것은 메모리를 효율적으로 다루기 어렵게 만든다.
        - 이러한 이유로 객체는 여러 식별자가 하나의 객체를 공유할 수 있다는 문제점을 가진다.
            
            ```jsx
            // 여러 식별자가 하나의 객체를 공유한다. 즉, obj 와 tmp 변수의 참조 값은 같은 객체를 참조하고 있다.
            const obj = { x: { y: "hello" } };
            const tmp_1 = obj;
            
            console.log(obj === tmp_1); //  true
            console.log(obj.x === tmp_1.x); // true
            
            // 얕은 복사
            // > 한 단계까지만 복사하는 것을 의미한다. 
            // > 즉, 가장 최상위 객체는 각각 다르지만 각각의 내부 프로퍼티들은 하나의 객체를 함께 참조하고 있다.
            const tmp_2 = { ...obj };
            
            console.log(obj === tmp_2); // false
            console.log(obj.x === tmp_2.x); // true
            
            // 깊은 복사
            // lodash 의 cloneDeep 을 사용한 깊은 복사
            // > 얕은 복사와는 달리 내부 프로퍼티 모두 다른 객체를 참조하고 있다.
            const _ = require('lodash');
            const tmp_3 = _.cloneDeep(obj);
            
            console.log(obj === tmp_3); // false
            console.log(obj.x === tmp_3.x); // false
            ```
            
- 변수가 기억하는 메모리 주소에 접근할 경우 원시 값처럼 값 그 자체에 접근하는 것이 아닌 객체가 할당된 메모리 주소에 접근하게 된다. 이 때의 객체가 할당된 메모리 주소에 접근하면 객체 즉, 참조 값에 접근할 수 있게 된다.

```jsx
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객쳋가 생성된다.
let person = {
	name: "성헌"
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
/*
	1. 변수 접근
	2. 변수가 기억하고 있는 메모리 주소 접근
	3. 해당 메모리 주소에는 실제 객체가 할당된 메모리 주소가 저장되어 있음(참조)
	4. 실제 객체의 메모리 주소에 접근하여 실제 객체에 접근
*/
console.log(person); // { name: "성헌" }
```

### 참조에 의한 전달

- 자바스크립트는 오직 값에 의한 전달만 존재한다. (`Pass By Value`)
- 객체가 할당된 변수가 존재하고 해당 변수를 복사본 변수에 재할당 한다고 가정 했을 때, 복사본 변수의 참조 값에는 원본 변수가 가지고 있는 객체를 새롭게 복사한 메모리 주소가 할당되는 것이 아닌, 원본 변수의 참조 값 그대로를 가지게 된다.
- 즉, 원본 변수와 복사본 변수의 참조 값은 동일한 메모리 주소를 바라보게 된다는 것이다.
- 때문에 원본 변수나 복사본 변수에서 객체의 프로퍼티를 변경하게 되면 서로 영향을 받게 된다.
- 결론적으로 값을 전달할 때, 객체의 경우 객체 데이터 그 자체를 전달하는 것이 아닌 객체가 할당된 메모리 주소를 전달하기 때문에 **값에 의한 전달(Pass By Value) 라고 보는 것이 맞다.**

```jsx
// 객체 리터럴로 person 식별자에 할당
let person = {
	name: "성헌"
};

// person 변수의 참조 값을 clonePerson 식별자에 할당
let clonePerson = person;

// clonePerson 이 참조하고 있는 객체에 age 프로퍼티 추가 및 값 설정
clonePerson.age = 10;

// person 과 clonePerson 의 프로퍼티 구성이 동일하다.
// 두 변수 모두 같은 객체의 메모리 주소를 참조하고 있기 때문이다.
console.log(person, clonePerson); // {name: '성헌', age: 10} {name: '성헌', age: 10}
console.log(person === clonePerson); // true
console.log(person.age === clonePerson.age); // true

```